<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>关系依赖图</title>
  <style>
    * {
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -khtml-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    #svg_div {
      width: 90vw;
      height: 90vh;
      border: 1px solid #c0c4cc;
      position: relative;
      left: 5vw;
      top: 5vh;
    }
  </style>
  <script type="text/javascript" src="http://d3js.org/d3.v5.min.js"></script>
</head>

<body>
  <div>
    <div id="svg_div"></div>
  </div>
  <script>
    const minX = 1000
    const minY = 1000
    const smallGrid = 20
    const Grid = 100
    const MARGIN_LEFT = 100
    const MARGIN_TOP = 50
    const EVERY_TOTAL_WIDTH = 150
    const EVERY_TOTAL_HEIGHT = 200

    //数据
    const dataset = {
      name: "glob",
      children: [
        {
          name: "minimatch",
          children: [
            {
              name: "brace-expansion",
              children: [
                { name: "balanced-match" }
              ]
            }
          ]
        },
        {
          name: "fs.realPath"
        },
        {
          name: "minipass"
        },
        {
          name: "path-s curry",
          children: [
            { name: "Iru-cache" }
          ]
        }
      ]
    };

    //创建一个hierarchy layout
    const hierarchyData = d3.hierarchy(dataset)
      .sum(function (d) {
        return d.value;
      });

    //创建一个树状图
    const tree = d3.tree()
      .size([minX, minY - 150])
      .separation((a, b) => a.depth + 1);

    //初始化树状图，也就是传入数据,并得到绘制树基本数据
    const treeData = tree(hierarchyData);
    console.log('data is:', treeData);

    //得到节点
    const nodes = treeData.descendants();
    const links = treeData.links();

    //输出节点和边
    console.log("节点:", nodes);
    console.log("边:", links);

    // 添加svg
    d3.select("#svg_div")
      .append("svg")
      .attr("id", "SVG")
      .attr("width", "100%")
      .attr("height", "100%")

    // 绘制栅格背景
    const defs = d3.select("SVG").append('defs')
    defs.append('pattern')
      .attr('id', 'smallGrid')
      .attr('width', smallGrid)
      .attr('height', smallGrid)
      .attr('patternUnits', 'userSpaceOnUse')
      .append('path')
      .attr('fill', 'none')
      .attr('stroke', 'gray')
      .attr('stoke-width', '0.5')

    const border = defs.append('pattern')
    border.attr('id', 'grid')
      .attr('width', Grid)
      .attr('height', Grid)
      .attr('patternUnits', 'userSpaceOnUse')
      .append('rect')
      .attr('width', Grid)
      .attr('height', Grid)
      .attr('fill', 'url(#smallGrid)')
    border.append('path')
      .attr('d', `M ${Grid} 0 L 0 0 0 ${Grid}`)
      .attr('fill', 'none')
      .attr('stroke', 'gray')
      .attr('stroke-width', '1')

    d3.select("SVG")
      .append('rect')
      .attr('id', 'bg-grid')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('fill', 'url(#grid)')
    d3.select("SVG")
      .call(d3.zoom()
        .scaleExtent([0.5, 4])
        .on('zoom', zoomed))

    // 拖拽缩放
    function zoomed() {
      d3.select("#graph").attr("transform", d3.event.transform)

      const k = d3.event.transform.k
      // 栅格缩放
      d3.select('#smallGrid')
        .attr('width', smallGrid * k)
        .attr('height', smallGrid * k)
      d3.select('#smallGrid')
        .select('path')
        .attr('width', smallGrid * k)
        .attr('height', smallGrid * k)
        .attr('d', `M ${smallGrid * k} 0 L 0 0 0 ${smallGrid * k}`)

      d3.select('#grid')
        .attr('width', Grid * k)
        .attr('height', Grid * k)
      d3.select('#grid')
        .select('rect')
        .attr('width', Grid * k)
        .attr('height', Grid * k)
      d3.select('#grid')
        .select('path')
        .attr('d', `M ${Grid * k} 0 L 0 0 0 ${Grid * k}`)
    }

    //定义边界
    const marge = { top: -30, bottom: 0, left: 50, right: 50 };

    d3.select("#SVG")
      .append("g")
      .attr("id", "graph")
      .attr("width", EVERY_TOTAL_WIDTH * nodes.length + MARGIN_LEFT)
      .attr("height", EVERY_TOTAL_HEIGHT * nodes.length + MARGIN_TOP)

    const g = d3.select("#graph").append("g")
      .attr("transform", "translate(" + marge.top + "," + marge.left + ")");

    const scale = d3.select("#graph").append("g")
      .attr("transform", "translate(" + marge.top + "," + marge.left + ")");


    //创建一个贝塞尔生成曲线生成器
    const Bezier_curve_generator = d3.linkHorizontal()
      .x(function (d) { return d.x; })
      .y(function (d) { return d.y; });

    // 定义箭头
    const arrowMarker = d3.select("SVG").append('defs')
      .append('marker')
      .attr('id', 'arrow')
      .attr('markerWidth', 15)
      .attr('markerHeight', 15)
      .attr('refX', 7)
      .attr('refY', 5)
      .attr('orient', 'auto')
      .attr('markerUnits', 'userSpaceOnUse');

    arrowMarker.append('path')
      .attr('d', 'M0,0 L0,10 L10,5 Z') // 定义箭头的形状
      .attr('fill', 'black');

    //绘制连线
    g.append('g')
      .selectAll('path')
      .data(links)
      .enter()
      .append('path')
      .attr('d', function (d) {
        const start = { x: d.source.x + 10, y: d.source.y + 30 };
        const end = { x: d.target.x + 30, y: d.target.y - 4 };
        return Bezier_curve_generator({ source: start, target: end });
      })
      .attr('fill', 'none')
      .attr('stroke', 'black')
      .attr('stroke-width', 1)
      .attr('marker-end', 'url(#arrow)'); // 添加箭头

    //绘制节点和文字
    const gs = g.append("g")
      .selectAll("g")
      .data(nodes)
      .enter()
      .append("g")
      .attr("transform", function (d) {
        const cx = d.x;
        const cy = d.y;
        return "translate(" + cx + "," + cy + ")";
      });

    // 绘制矩形节点
    gs.append("rect")
      .attr("width", 100)
      .attr("height", 50)
      .attr("fill", "white")
      .attr("stroke", "black")
      .attr("stroke-width", 1)

    // 绘制文字
    gs.append("text")
      .attr("x", 50) // 设置文字的水平居中位置
      .attr("y", 25) // 设置文字的垂直居中位置
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle") // 垂直对齐方式设为middle
      .text(function (d) {
        return d.data.name;
      });

    // 遍历节点
    gs.each(function (d) {
      const textNode = d3.select(this).select("text"); // 当前节点下的文本元素
      const textLength = textNode.node().getComputedTextLength(); // 获取文本长度
      const rectNode = d3.select(this).select("rect"); // 当前节点下的矩形元素
      rectNode.attr("width", Math.max(50, textLength + 20)); // 动态设置矩形节点的宽度
      textNode.attr('x', (textLength + 20) / 2); // 动态设置文字的水平位置
    });

  </script>
</body>

</html>